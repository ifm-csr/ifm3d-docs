\hypertarget{classifm3d_1_1PCICClient}{}\doxysection{ifm3d\+::P\+C\+I\+C\+Client Class Reference}
\label{classifm3d_1_1PCICClient}\index{ifm3d::PCICClient@{ifm3d::PCICClient}}


{\ttfamily \#include $<$ifm3d/pcicclient/pcicclient.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classifm3d_1_1PCICClient_a8f696d08e216e9c10a8f692940b156a0}\label{classifm3d_1_1PCICClient_a8f696d08e216e9c10a8f692940b156a0}} 
using {\bfseries Ptr} = std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} $>$
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classifm3d_1_1PCICClient_a216862c9f37385ec769d848d8a0283ec}{P\+C\+I\+C\+Client}} (ifm3d\+::\+Legacy\+Device\+::\+Ptr cam, const std\+::uint16\+\_\+t pcic\+\_\+port=ifm3d\+::\+P\+C\+I\+C\+\_\+\+P\+O\+RT)
\item 
virtual \mbox{\hyperlink{classifm3d_1_1PCICClient_a23868be539bfc42602863864ac7c05e0}{$\sim$\+P\+C\+I\+C\+Client}} ()
\item 
\mbox{\Hypertarget{classifm3d_1_1PCICClient_ab306f8ba4593e065f8cf7c2711d5cafd}\label{classifm3d_1_1PCICClient_ab306f8ba4593e065f8cf7c2711d5cafd}} 
{\bfseries P\+C\+I\+C\+Client} (\mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} \&\&)=delete
\item 
\mbox{\Hypertarget{classifm3d_1_1PCICClient_aade80de4cdbc03f14cf57c7f716ab34a}\label{classifm3d_1_1PCICClient_aade80de4cdbc03f14cf57c7f716ab34a}} 
\mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} \& {\bfseries operator=} (\mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} \&\&)=delete
\item 
\mbox{\Hypertarget{classifm3d_1_1PCICClient_a7823578785018927cb7ac55b12e483e3}\label{classifm3d_1_1PCICClient_a7823578785018927cb7ac55b12e483e3}} 
{\bfseries P\+C\+I\+C\+Client} (\mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} \&)=delete
\item 
\mbox{\Hypertarget{classifm3d_1_1PCICClient_a423323a9909b3190cfed26d513cf5512}\label{classifm3d_1_1PCICClient_a423323a9909b3190cfed26d513cf5512}} 
\mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} \& {\bfseries operator=} (const \mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} \&)=delete
\item 
void \mbox{\hyperlink{classifm3d_1_1PCICClient_ae76ab7d6821e6c46b65f788045385de4}{Stop}} ()
\item 
long \mbox{\hyperlink{classifm3d_1_1PCICClient_a5b33d371605d558fbfa6c90fd69f36bb}{Call}} (const std\+::string \&request, std\+::function$<$ void(const std\+::string \&response)$>$ callback)
\item 
std\+::string \mbox{\hyperlink{classifm3d_1_1PCICClient_a0c55134f22d23542449344bcf898e9e0}{Call}} (const std\+::string \&request)
\item 
bool \mbox{\hyperlink{classifm3d_1_1PCICClient_a0f6cfe3e11f0e73c95d0ce34d98fb027}{Call}} (const std\+::string \&request, std\+::string \&response, long timeout\+\_\+millis)
\item 
long \mbox{\hyperlink{classifm3d_1_1PCICClient_a6e003c59cae62678410aadeb06967ee7}{Set\+Error\+Callback}} (std\+::function$<$ void(const std\+::string \&error)$>$ callback)
\item 
long \mbox{\hyperlink{classifm3d_1_1PCICClient_a600017cd6a147eab52e8422e8cf82788}{Set\+Notification\+Callback}} (std\+::function$<$ void(const std\+::string \&notification)$>$ callback)
\item 
void \mbox{\hyperlink{classifm3d_1_1PCICClient_a55ab9adeb7a46dfa5ec55a28327bceaf}{Cancel\+Callback}} (long callback\+\_\+id)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The \mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} is a class that, when given access to an ifm3d\+::\+Camera\+::\+Ptr, it provides unbuffered communication with the P\+C\+IC interface. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classifm3d_1_1PCICClient_a216862c9f37385ec769d848d8a0283ec}\label{classifm3d_1_1PCICClient_a216862c9f37385ec769d848d8a0283ec}} 
\index{ifm3d::PCICClient@{ifm3d::PCICClient}!PCICClient@{PCICClient}}
\index{PCICClient@{PCICClient}!ifm3d::PCICClient@{ifm3d::PCICClient}}
\doxysubsubsection{\texorpdfstring{PCICClient()}{PCICClient()}}
{\footnotesize\ttfamily ifm3d\+::\+P\+C\+I\+C\+Client\+::\+P\+C\+I\+C\+Client (\begin{DoxyParamCaption}\item[{ifm3d\+::\+Legacy\+Device\+::\+Ptr}]{cam,  }\item[{const std\+::uint16\+\_\+t}]{pcic\+\_\+port = {\ttfamily ifm3d\+:\+:PCIC\+\_\+PORT} }\end{DoxyParamCaption})}

Stores reference to the passed in camera and starts connect/receive thread


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cam} & The \mbox{\hyperlink{classifm3d_1_1Device}{Device}} instance to grab frames from \\
\hline
\mbox{\texttt{ in}}  & {\em nat\+\_\+pcic\+\_\+port} & pcic port for N\+AT configuartion \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classifm3d_1_1PCICClient_a23868be539bfc42602863864ac7c05e0}\label{classifm3d_1_1PCICClient_a23868be539bfc42602863864ac7c05e0}} 
\index{ifm3d::PCICClient@{ifm3d::PCICClient}!````~PCICClient@{$\sim$PCICClient}}
\index{````~PCICClient@{$\sim$PCICClient}!ifm3d::PCICClient@{ifm3d::PCICClient}}
\doxysubsubsection{\texorpdfstring{$\sim$PCICClient()}{~PCICClient()}}
{\footnotesize\ttfamily virtual ifm3d\+::\+P\+C\+I\+C\+Client\+::$\sim$\+P\+C\+I\+C\+Client (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Cleans up any resources held by the receive thread object and blocks until the operating system thread stops. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classifm3d_1_1PCICClient_a0c55134f22d23542449344bcf898e9e0}\label{classifm3d_1_1PCICClient_a0c55134f22d23542449344bcf898e9e0}} 
\index{ifm3d::PCICClient@{ifm3d::PCICClient}!Call@{Call}}
\index{Call@{Call}!ifm3d::PCICClient@{ifm3d::PCICClient}}
\doxysubsubsection{\texorpdfstring{Call()}{Call()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily std\+::string ifm3d\+::\+P\+C\+I\+C\+Client\+::\+Call (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{request }\end{DoxyParamCaption})}

Sends a P\+C\+IC command to the camera and returns the response as soon as it has been received. In the meanwhile, this call is blocked.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em request} & String containing the plain command (without any header infomration, like ticket, length, etc.)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Copy of received plain response data as string (without any header information, like ticket, length, etc.)
\end{DoxyReturn}
N\+O\+TE\+: This Call can block and hang indefinitely depending upon P\+C\+IC response. \mbox{\Hypertarget{classifm3d_1_1PCICClient_a5b33d371605d558fbfa6c90fd69f36bb}\label{classifm3d_1_1PCICClient_a5b33d371605d558fbfa6c90fd69f36bb}} 
\index{ifm3d::PCICClient@{ifm3d::PCICClient}!Call@{Call}}
\index{Call@{Call}!ifm3d::PCICClient@{ifm3d::PCICClient}}
\doxysubsubsection{\texorpdfstring{Call()}{Call()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily long ifm3d\+::\+P\+C\+I\+C\+Client\+::\+Call (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{request,  }\item[{std\+::function$<$ void(const std\+::string \&response)$>$}]{callback }\end{DoxyParamCaption})}

Sends a P\+C\+IC command to the camera and returns the response asynchronously through a callback (, which is automatically removed internally after the callback returns).

Note\+: Since the \mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} is unbuffered, the calling thread will be blocked while the request is not completely sent. Also, the receiving thread will be blocked while the response callback has not returned.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em request} & String containing the plain command (without any header information, like ticket, length, etc.)\\
\hline
\mbox{\texttt{ in}}  & {\em callback} & Function, called after receiving the response from the camera, providing the plain response data as string (without any header information, like ticket, length, etc.)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Callback id, which can be used to cancel this Call before receiving the response. 
\end{DoxyReturn}
\mbox{\Hypertarget{classifm3d_1_1PCICClient_a0f6cfe3e11f0e73c95d0ce34d98fb027}\label{classifm3d_1_1PCICClient_a0f6cfe3e11f0e73c95d0ce34d98fb027}} 
\index{ifm3d::PCICClient@{ifm3d::PCICClient}!Call@{Call}}
\index{Call@{Call}!ifm3d::PCICClient@{ifm3d::PCICClient}}
\doxysubsubsection{\texorpdfstring{Call()}{Call()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily bool ifm3d\+::\+P\+C\+I\+C\+Client\+::\+Call (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{request,  }\item[{std\+::string \&}]{response,  }\item[{long}]{timeout\+\_\+millis }\end{DoxyParamCaption})}

Similar to the Call function above.

Sends a P\+C\+IC command to the camera and returns the response as soon as it has been received. In the meanwhile, this call is blocked.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em request} & String containing the plain command (without any header infomration, like ticket, length, etc.)\\
\hline
\mbox{\texttt{ in}}  & {\em response} & String containing the response from the camera providing the plain response data as string (without any header information, like ticket, length, etc.)\\
\hline
\mbox{\texttt{ in}}  & {\em timeout} & in milliseconds, in case, the P\+C\+IC fails to come through.\\
\hline
\end{DoxyParams}
N\+O\+TE\+: This Call can fail with no response if supplied with an unsuitable \char`\"{}timeout\+\_\+millis\char`\"{} value. Providing timeout\+\_\+millis value as 0 results in behaviour similar to the above Call method.

\begin{DoxyReturn}{Returns}
true if Call succeeded, false if failed. 
\end{DoxyReturn}
\mbox{\Hypertarget{classifm3d_1_1PCICClient_a55ab9adeb7a46dfa5ec55a28327bceaf}\label{classifm3d_1_1PCICClient_a55ab9adeb7a46dfa5ec55a28327bceaf}} 
\index{ifm3d::PCICClient@{ifm3d::PCICClient}!CancelCallback@{CancelCallback}}
\index{CancelCallback@{CancelCallback}!ifm3d::PCICClient@{ifm3d::PCICClient}}
\doxysubsubsection{\texorpdfstring{CancelCallback()}{CancelCallback()}}
{\footnotesize\ttfamily void ifm3d\+::\+P\+C\+I\+C\+Client\+::\+Cancel\+Callback (\begin{DoxyParamCaption}\item[{long}]{callback\+\_\+id }\end{DoxyParamCaption})}

Cancels registered callbacks. Must be called in case references/pointers provided through callbacks get invalid. If callback id isn\textquotesingle{}t present internally anymore, i.\+e. if callback was replaced, already canceled or automatically removed (in case of the Call method), it is simply ignored.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em callback\+\_\+id} & Callback id, returned by methods which take a callback as parameter. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classifm3d_1_1PCICClient_a6e003c59cae62678410aadeb06967ee7}\label{classifm3d_1_1PCICClient_a6e003c59cae62678410aadeb06967ee7}} 
\index{ifm3d::PCICClient@{ifm3d::PCICClient}!SetErrorCallback@{SetErrorCallback}}
\index{SetErrorCallback@{SetErrorCallback}!ifm3d::PCICClient@{ifm3d::PCICClient}}
\doxysubsubsection{\texorpdfstring{SetErrorCallback()}{SetErrorCallback()}}
{\footnotesize\ttfamily long ifm3d\+::\+P\+C\+I\+C\+Client\+::\+Set\+Error\+Callback (\begin{DoxyParamCaption}\item[{std\+::function$<$ void(const std\+::string \&error)$>$}]{callback }\end{DoxyParamCaption})}

Sets the specified callback for receiving asynchronous error messages until it is replaced by a new callback or canceled via \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classifm3d_1_1PCICClient_a55ab9adeb7a46dfa5ec55a28327bceaf}{Cancel\+Callback}}.
\end{DoxySeeAlso}
Note\+: Since the \mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} is unbuffered, the receiving thread will be blocked while the error callback has not returned.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em callback} & Function, called after receiving an error message from camera (without any header information, like ticket, length, etc.)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Callback id, which can be used to cancel receiving errors. 
\end{DoxyReturn}
\mbox{\Hypertarget{classifm3d_1_1PCICClient_a600017cd6a147eab52e8422e8cf82788}\label{classifm3d_1_1PCICClient_a600017cd6a147eab52e8422e8cf82788}} 
\index{ifm3d::PCICClient@{ifm3d::PCICClient}!SetNotificationCallback@{SetNotificationCallback}}
\index{SetNotificationCallback@{SetNotificationCallback}!ifm3d::PCICClient@{ifm3d::PCICClient}}
\doxysubsubsection{\texorpdfstring{SetNotificationCallback()}{SetNotificationCallback()}}
{\footnotesize\ttfamily long ifm3d\+::\+P\+C\+I\+C\+Client\+::\+Set\+Notification\+Callback (\begin{DoxyParamCaption}\item[{std\+::function$<$ void(const std\+::string \&notification)$>$}]{callback }\end{DoxyParamCaption})}

Sets the specified callback for receiving asynchronous notification messages until it is replaced by a new callback or canceled via \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classifm3d_1_1PCICClient_a55ab9adeb7a46dfa5ec55a28327bceaf}{Cancel\+Callback}}.
\end{DoxySeeAlso}
Note\+: Since the \mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} is unbuffered, the receiving thread will be blocked while the notification callback has not returned.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em callback} & Function, called after receiving an notification message from camera (without any header information, like ticket, length, etc.)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Callback id, which can be used to cancel receiving notifications. 
\end{DoxyReturn}
\mbox{\Hypertarget{classifm3d_1_1PCICClient_ae76ab7d6821e6c46b65f788045385de4}\label{classifm3d_1_1PCICClient_ae76ab7d6821e6c46b65f788045385de4}} 
\index{ifm3d::PCICClient@{ifm3d::PCICClient}!Stop@{Stop}}
\index{Stop@{Stop}!ifm3d::PCICClient@{ifm3d::PCICClient}}
\doxysubsubsection{\texorpdfstring{Stop()}{Stop()}}
{\footnotesize\ttfamily void ifm3d\+::\+P\+C\+I\+C\+Client\+::\+Stop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Interrupts the running thread by throwing an ifm3d\+::error\+\_\+t with code I\+F\+M3\+D\+\_\+\+T\+H\+R\+E\+A\+D\+\_\+\+I\+N\+T\+E\+R\+R\+U\+P\+T\+ED.

While this is (currently) part of the public interface, clients should be aware that there is really no way to restart a stopped \mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}} instance. To do that, you would need to instantiate a new \mbox{\hyperlink{classifm3d_1_1PCICClient}{P\+C\+I\+C\+Client}}. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
ifm3d/pcicclient/pcicclient.\+h\end{DoxyCompactItemize}
